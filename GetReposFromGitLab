<#
    This script:
    - Takes a GitLab group path (e.g. "microsoft/portal" from https://gitlab.com/microsoft/portal)
    - Lists all projects under that group (and subgroups)
    - For each project:
        * Finds the default branch
        * Tries to get the last merged MR into that branch
        * If no merged MR, falls back to the latest commit on that branch
        * Derives a project status: active / archived / pending_deletion
    - Exports a CSV with:
        RepositoryName, DefaultBranch, LastChangeDate, ProjectStatus

    Requirements:
    - PowerShell 5+ or PowerShell 7+
    - GitLab Personal Access Token with at least "read_api" scope
#>

# ==== CONFIG ====
$GitLabBaseUrl = "https://gitlab.com/api/v4"
$GroupPath     = "microsoft/portal"         # <-- change to your group/subgroup path
$GitLabToken   = "<PUT_YOUR_TOKEN_HERE>"    # <-- must have read_api
$OutputCsv     = "gitlab_repos_last_change.csv"
# ================

# Build headers
$Headers = @{}
if (-not [string]::IsNullOrWhiteSpace($GitLabToken)) {
    $Headers["PRIVATE-TOKEN"] = $GitLabToken
}

# URL-encode the group path (handles slashes, spaces, etc.)
$encodedGroupPath = [System.Uri]::EscapeDataString($GroupPath)

Write-Host "Getting group info for '$GroupPath'..."

# Get group info to obtain numeric ID
try {
    $groupUrl = "$GitLabBaseUrl/groups/$encodedGroupPath"
    $group = Invoke-RestMethod -Uri $groupUrl -Headers $Headers -Method Get -ErrorAction Stop
} catch {
    $resp = $_.Exception.Response
    if ($resp -and $resp.GetResponseStream()) {
        $reader = New-Object System.IO.StreamReader($resp.GetResponseStream())
        $body = $reader.ReadToEnd()
        Write-Error "Failed to fetch group information. Status: $($resp.StatusCode) $($resp.StatusDescription). Body: $body"
    } else {
        Write-Error "Failed to fetch group information. Error: $($_.Exception.Message)"
    }
    return
}

$groupId = $group.id
Write-Host "Group ID: $groupId"

# Fetch all projects under the group (including subgroups), with pagination
Write-Host "Fetching projects under the group (including subgroups)..."

$projects = @()
$page     = 1
$perPage  = 100

while ($true) {
    $projectsUrl  = "$GitLabBaseUrl/groups/$groupId/projects?per_page=$perPage&page=$page&include_subgroups=true"
    $projectsPage = Invoke-RestMethod -Uri $projectsUrl -Headers $Headers -Method Get

    if (-not $projectsPage -or $projectsPage.Count -eq 0) {
        break
    }

    $projects += $projectsPage
    $page++
}

Write-Host "Total projects found: $($projects.Count)"

$result = @()

foreach ($proj in $projects) {
    $projectId     = $proj.id
    $projectName   = $proj.path_with_namespace
    $defaultBranch = $proj.default_branch

    # Derive project status from GitLab fields
    # archived (bool), marked_for_deletion_on (date or null)
    $isArchived           = $false
    $markedForDeletionOn  = $null
    $projectStatus        = "active"

    if ($null -ne $proj.archived) {
        $isArchived = [bool]$proj.archived
    }

    # Some instances might not have this field if older version, so guard for null
    if ($proj.PSObject.Properties.Name -contains "marked_for_deletion_on") {
        $markedForDeletionOn = $proj.marked_for_deletion_on
    }

    if ($isArchived -and $markedForDeletionOn) {
        $projectStatus = "pending_deletion"
    } elseif ($isArchived) {
        $projectStatus = "archived"
    } elseif ($markedForDeletionOn) {
        # Defensive, in case instance sets marked_for_deletion_on without archived=true
        $projectStatus = "pending_deletion"
    } else {
        $projectStatus = "active"
    }

    if (-not $defaultBranch) {
        Write-Warning "Project '$projectName' has no default branch (skipping MR/commit lookup)."
        $result += [pscustomobject]@{
            RepositoryName = $projectName
            DefaultBranch  = ""
            LastChangeDate = ""
            ProjectStatus  = $projectStatus
        }
        continue
    }

    Write-Host "Processing project: $projectName (default branch: $defaultBranch, status: $projectStatus)"

    $lastChangeDate = $null

    # 1) Try last merged MR into the default branch
    try {
        # GET /projects/:id/merge_requests
        $mrUrl = "$GitLabBaseUrl/projects/$projectId/merge_requests?state=merged&target_branch=$([System.Uri]::EscapeDataString($defaultBranch))&order_by=updated_at&sort=desc&per_page=1"
        $mrs = Invoke-RestMethod -Uri $mrUrl -Headers $Headers -Method Get

        if ($mrs -and $mrs.Count -gt 0) {
            $lastMr = $mrs[0]
            # Prefer merged_at; if null, fall back to updated_at
            $lastChangeDate = $lastMr.merged_at
            if (-not $lastChangeDate) {
                $lastChangeDate = $lastMr.updated_at
            }
        }
    } catch {
        Write-Warning "Failed to get merge requests for project '$projectName': $($_.Exception.Message)"
    }

    # 2) If no merged MR, fall back to latest commit on default branch
    if (-not $lastChangeDate) {
        try {
            # GET /projects/:id/repository/commits?ref_name=<branch>&per_page=1
            $commitsUrl = "$GitLabBaseUrl/projects/$projectId/repository/commits?ref_name=$([System.Uri]::EscapeDataString($defaultBranch))&per_page=1"
            $commits = Invoke-RestMethod -Uri $commitsUrl -Headers $Headers -Method Get

            if ($commits -and $commits.Count -gt 0) {
                $lastCommit = $commits[0]
                # committed_date is usually what you want
                $lastChangeDate = $lastCommit.committed_date
            } else {
                Write-Warning "No commits found on branch '$defaultBranch' for project '$projectName'."
            }
        } catch {
            Write-Warning "Failed to get commits for project '$projectName': $($_.Exception.Message)"
        }
    }

    # Convert lastChangeDate to date-only string (yyyy-MM-dd)
    $lastChangeDateOnly = $null
    if ($lastChangeDate) {
        try {
            $lastChangeDateOnly = ([datetime]$lastChangeDate).ToString("yyyy-MM-dd")
        } catch {
            # Fallback to raw value if parse fails
            $lastChangeDateOnly = $lastChangeDate
        }
    }

    $result += [pscustomobject]@{
        RepositoryName = $projectName
        DefaultBranch  = $defaultBranch
        LastChangeDate = $lastChangeDateOnly
        ProjectStatus  = $projectStatus
    }
}

Write-Host "Exporting results to CSV: $OutputCsv"
$result | Export-Csv -Path $OutputCsv -NoTypeInformation -Encoding UTF8
Write-Host "Done. CSV created at '$OutputCsv'."